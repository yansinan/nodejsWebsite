<script>
    this.bsTimelineBarWrapper = new BetterScroll.createBScroll('#bsTimelineBarWrapper', {
        //specifiedIndexAsContent:1,
        disableMouse: false,
        disableTouch: false,
        scrollX: true,
        scrollY: false,
        //nestedScroll: {
        //    groupId: 'cover-scrollY'
        //},
        //slide: {
        //    threshold: 100,
        //    loop: false,//TODO：可以优化为循环slide；注意：复制出来的slide需要querySelector and 设置translateY同步
        //    autoplay:false,
        //    listenFlick:false,
        //},
        useTransition: true,
        momentum: true,
        //momentumLimitTime:100,//{# 快速滑动的时间小于xx开启#}
        //momentumLimitDistance:50,//{# 快速滑动的距离大于xx开启#}
        //deceleration:0.005,//{# momentum 动画的减速度 #}
        //swipeTime:300,//{# momentum 动画时长 #}
        bounce: {
            top: true,
            bottom: true,
            left: true,
            right: true
        },
        mouseWheel: {
            speed: 50,
            invert: false,
            easeTime: 100
        },
        observeDOM: true ,// 开启 observe-dom 插件
        stopPropagation: false,
        probeType: 3,
    })
    {# 手机版使用坐标转换 #}
    this.bsTimelineBarWrapper.scroller.actions.hooks.on('coordinateTransformation', (transformateDeltaData) => { 
        // 获取用户手指移动的距离
        const originDeltaX = transformateDeltaData.deltaX
        const originDeltaY = transformateDeltaData.deltaY
        // 变换位移
        transformateDeltaData.deltaX = originDeltaY// transformateDeltaData.deltaX 最终作用在 BetterScroll content DOM 的 translateX
        transformateDeltaData.deltaY = originDeltaX// transformateDeltaData.deltaY 最终作用在 BetterScroll content DOM 的 translateY
    })
    {# 移动中对齐内容，控制年份跟踪 #}
    //this.bsTimelineBarWrapper.scroller.translater.hooks.on('translate', (point) => {
    //    let bs=this.bsTimelineBarWrapper;
    //    let $timelineYearContainer=document.getElementById("timelineYearContainer");
    //    let $firstYear=$timelineYearContainer.querySelector("#timelineYearContainer .timelineYear");
    //    $firstYear.style.left = point.x + "px";
    //})

    let $bsTimelineBarWrapper=document.getElementById("bsTimelineBarWrapper");
    let $timelineYearContainer=document.getElementById("timelineYearContainer");
    let $svgTimelineBar=document.getElementById("svgTimelineBar");

    function updateBnYear(paramTimeline,$year,idx,$list){

        let strYear=$year.querySelector("span").innerText;

        let $timelineBarYearGroup=$svgTimelineBar.getElementById("timelineBarYearGroup"+strYear);
        let $yearPos=document.getElementById("timelineBarYear"+strYear);
        {# 计算过程 #}
        {# 宽度 #}
        //let wTimelineYearGroup=$timelineBarYearGroup.attributes["width-year"].value * $svgTimelineBar.clientWidth/100;
        {# 年坐标在wrapper中的相对x% #}
        //let xOffset = $svgTimelineBar.clientWidth*($yearPos.attributes.x.value.replace("%","")/100)+paramTimeline.position.x;//Math.max(0,position.x + "px");
        let xOffset = $yearPos.x.baseVal.value + paramTimeline.position.x;
        let xTo=(paramTimeline.start+Math.round(xOffset));//$year.style.left-xOffset;
        

        {# z-index #}
        if(xTo<paramTimeline.end && xTo>paramTimeline.start)$year.style["z-index"]=4000;
        else if(xTo<paramTimeline.start)$year.style["z-index"]=4000-strYear;
        else if(xTo>paramTimeline.end)$year.style["z-index"]=strYear;

        {# 判断是否超出右停止位 #}
        xTo=Math.max(Math.min(xTo,paramTimeline.end),paramTimeline.start);

        {# 碰撞挤出 检查左侧#}
        let $left= idx>0 ? $list[idx-1] : false;    
        if($left){
            let xLeft=$left.style.opacity!="0" ? parseInt($left.style.left.replace("px","")):false;
            {# 只有最左侧才往左推，否则右侧会影响左侧 #}
            if(xLeft <= paramTimeline.start && xLeft + paramTimeline.wYear >= xTo){
                let xLeftTo=Math.max(Math.min(xLeft,(xTo - paramTimeline.wYear)),paramTimeline.startLeft);
                $left.style.left=xLeftTo+"px";
                {# $left.style.opacity = ( xLeftTo <= paramTimeline.startLeft )?"0":"1"; #}
                $left.style.opacity = Math.abs(( xLeftTo - paramTimeline.startLeft )/paramTimeline.wYear);
            }
            {# 左推右，必须在end附近，否则循环修改 #}
            if(xTo >= paramTimeline.end)xTo=Math.min(Math.max(xLeft + paramTimeline.wYear, xTo),paramTimeline.endRight);
        }
        {# 调整过左侧，最后确定自身坐标 #}
        $year.style.left=xTo+"px";
        {# $year.style.opacity = ( xTo >= paramTimeline.endRight )?"0":"1"; #}
        $year.style.opacity = Math.abs(( xTo - paramTimeline.endRight )/paramTimeline.wYear);
    }

    function updateTimelineBar(position={x:0}){
        {# 初始化参数 #}
        let paramTimeline={
            wWrapper:$bsTimelineBarWrapper.clientWidth,
            wYear:$timelineYearContainer.querySelector("#timelineYearContainer .timelineYear span").clientWidth,
        }
        {# 位置 #}
        Object.assign(paramTimeline,{
            startLeft: -paramTimeline.wWrapper - paramTimeline.wYear,
            start: -paramTimeline.wWrapper,
            end:0,
            endRight:paramTimeline.wYear,
            position:position,
        })
        let $listYears=$timelineYearContainer.querySelectorAll("#timelineYearContainer .timelineYear");
        $listYears.forEach(($year,idx,$list)=>{
            updateBnYear(paramTimeline,$year,idx,$list);
        })
        //$listYears.forEach(pushBnYear);
        {# 触发事件 #}
        that.dispatchEvent(new CustomEvent("BS_TIMELINE_BAR_SCROLL", {
            detail:{
                strDateNow:"",
            }
        }))
    }
    this.bsTimelineBarWrapper.on('scroll', updateTimelineBar);
    updateTimelineBar();

    
    {# 时间轴scroll #}
    this.addEventListener("BS_MAIN_SCROLL",(e)=>{
        let $now=document.getElementById("b"+e.detail.strDateNow);
        let posX=-$now.x.baseVal.value;//-$now.x*$svgTimelineBar.clientWidth;
        this.bsTimelineBarWrapper.scrollTo(posX);
    })
</script>