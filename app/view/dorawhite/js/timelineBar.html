<script>
    this.bsTimelineBarWrapper = new BetterScroll.createBScroll('#bsTimelineBarWrapper', {
        //specifiedIndexAsContent:1,
        disableMouse: false,
        disableTouch: false,
        scrollX: true,
        scrollY: false,
        //nestedScroll: {
        //    groupId: 'cover-scrollY'
        //},
        //slide: {
        //    threshold: 100,
        //    loop: false,//TODO：可以优化为循环slide；注意：复制出来的slide需要querySelector and 设置translateY同步
        //    autoplay:false,
        //    listenFlick:false,
        //},
        useTransition: true,
        momentum: true,
        //momentumLimitTime:100,//{# 快速滑动的时间小于xx开启#}
        //momentumLimitDistance:50,//{# 快速滑动的距离大于xx开启#}
        //deceleration:0.005,//{# momentum 动画的减速度 #}
        //swipeTime:300,//{# momentum 动画时长 #}
        bounce: {
            top: true,
            bottom: true,
            left: true,
            right: true
        },
        mouseWheel: {
            speed: 50,
            invert: false,
            easeTime: 100
        },
        observeDOM: true ,// 开启 observe-dom 插件
        stopPropagation: false,
        probeType: 3,
    })
    {# 手机版使用坐标转换 #}
    this.bsTimelineBarWrapper.scroller.actions.hooks.on('coordinateTransformation', (transformateDeltaData) => { 
        // 获取用户手指移动的距离
        const originDeltaX = transformateDeltaData.deltaX
        const originDeltaY = transformateDeltaData.deltaY
        // 变换位移
        transformateDeltaData.deltaX = originDeltaY// transformateDeltaData.deltaX 最终作用在 BetterScroll content DOM 的 translateX
        transformateDeltaData.deltaY = originDeltaX// transformateDeltaData.deltaY 最终作用在 BetterScroll content DOM 的 translateY
    })
    {# 移动中对齐内容，控制年份跟踪 #}
    //this.bsTimelineBarWrapper.scroller.translater.hooks.on('translate', (point) => {
    //    let bs=this.bsTimelineBarWrapper;
    //    let $timelineYearContainer=document.getElementById("timelineYearContainer");
    //    let $firstYear=$timelineYearContainer.querySelector("#timelineYearContainer .timelineYear");
    //    $firstYear.style.left = point.x + "px";
    //})
    const getOffsetLeft = function(obj){
              const tmp = obj.offsetLeft;
              const val = obj.offsetParent;
              while(val != null){
              tmp += val.offsetLeft;
                val = val.offsetParent;
               }
            return tmp;
    }
    let $bsTimelineBarWrapper=document.getElementById("bsTimelineBarWrapper");
    let $timelineYearContainer=document.getElementById("timelineYearContainer");

    let paramTimeline={
        wWrapper:$bsTimelineBarWrapper.clientWidth,
        wYear:$timelineYearContainer.querySelector("#timelineYearContainer .timelineYear span").clientWidth,
    }
    {# 位置 #}
    Object.assign(paramTimeline,{
        startLeft: -paramTimeline.wWrapper - paramTimeline.wYear,
        start: -paramTimeline.wWrapper,
        end:0,
        endRight:paramTimeline.wYear,
    })
    //let wWrapper=$bsTimelineBarWrapper.clientWidth;
    //let start= -wWrapper;
    //let end=0;
    let $svgTimelineBar=document.getElementById("svgTimelineBar");
    function updateBnYear(position,$year,idx,$list){

        let strYear=$year.querySelector("span").innerText;

        let $timelineBarYearGroup=$svgTimelineBar.getElementById("timelineBarYearGroup"+strYear);
        let $yearPos=document.getElementById("timelineBarYear"+strYear);
        {# 计算过程 #}
        {# 宽度 #}
        //let wTimelineYearGroup=$timelineBarYearGroup.attributes["width-year"].value * $svgTimelineBar.clientWidth/100;
        {# 年坐标在wrapper中的相对x% #}
        let xOffset = $svgTimelineBar.clientWidth*($yearPos.attributes.x.value.replace("%","")/100)+position.x;//Math.max(0,position.x + "px");
        let xTo=(paramTimeline.start+Math.round(xOffset));//$year.style.left-xOffset;
        

        {# z-index #}
        if(xTo<paramTimeline.end && xTo>paramTimeline.start)$year.style["z-index"]=4000;
        else if(xTo<paramTimeline.start)$year.style["z-index"]=4000-strYear;
        else if(xTo>paramTimeline.end)$year.style["z-index"]=strYear;

        {# 超出显示区,并且当前年份组仍在显示中 #}
        //let isTooFar=(xOffset > wWrapper + wTimelineYearGroup) || (xOffset < -wTimelineYearGroup)
        //let isInWrapper=xTo>start && xTo<end; 
        //if(isTooFar){
        //    {# $year.style.display="none"; #}
        //    {# return; #}
        //}else{
        //    $year.style.display="flex";
        //    //if(!(xTo<startLeft || xTo > endRight)){
        //    //    {# 判断是否超出右停止位 #}
        //    //    if(xTo>end)xTo=end;
        //    //    {# 左边停止位 #}
        //    //    if(xTo<start)xTo=start;            
        //    //}else if(!isTooFar){
        //    //    {# 第二级位移计算 #}
        //    //    if(xOffset > -wTimelineYearGroup)xTo=Math.max(startLeft,xTo);
        //    //    if(xOffset < wWrapper + wTimelineYearGroup)xTo=Math.min(endRight,xTo);
        //    //}
        //    {# 判断是否超出右停止位 #}
        //    if(xTo>end)xTo=end;
        //    {# 左边停止位 #}
        //    if(xTo<start)xTo=start;            
        //    
        //}
        {# 判断是否超出右停止位 #}
        xTo=Math.max(Math.min(xTo,paramTimeline.end),paramTimeline.start);
        $year.style.left=xTo+"px";


        {# 碰撞挤出 #}
        let $left= idx>0 ? $list[idx-1] : false;

        let wLeft=paramTimeline.wYear;//$left?$left.querySelector("span").clientWidth:0;
        let wYear=paramTimeline.wYear;//$year.querySelector("span").clientWidth;

        let xLeft=$left && $left.style.display!="none" ? $left.style.left.replace("px",""):false;
        let xYear=$year.style.left?$year.style.left.replace("px",""):false;
        xLeft=parseInt(xLeft);
        xYear=parseInt(xYear);
        {# 检查左侧 #}        
        if($left){
            {# 只有最左侧才往左推，否则右侧会影响左侧 #}
            if(xLeft <= paramTimeline.start && xLeft + wLeft >= xYear){
                let xLeftTo=Math.max(Math.min(xLeft,(xYear - wLeft)),paramTimeline.startLeft);
                $left.style.left=xLeftTo+"px";
                $left.style.display = ( xLeftTo >= paramTimeline.endRight )?"none":"flex";
            }
            if(xLeft >= paramTimeline.end - wLeft && xLeft + wLeft >= xYear){
                let xYearTo=Math.min(Math.max(xLeft + wLeft, xYear),paramTimeline.endRight);
                $year.style.left=xYearTo+"px";
                $year.style.display = ( xYearTo >= paramTimeline.endRight )?"none":"flex";
            }
            
        }
    }
    //function pushBnYear($year,idx,$list){
    //    let $left= idx>0 ? $list[idx-1] : false;
    //    let wLeft=paramTimeline.wYear;//$left?$left.querySelector("span").clientWidth:0;
    //    let wYear=paramTimeline.wYear;//$year.querySelector("span").clientWidth;
    //    let xLeft=$left && $left.style.display!="none" ? $left.style.left.replace("px",""):false;
    //    let xYear=$year.style.left?$year.style.left.replace("px",""):false;
    //    xLeft=parseInt(xLeft);
    //    xYear=parseInt(xYear);
    //    {# 检查左侧 #}        
    //    if($left){
    //        {# 只有最左侧才往左推，否则右侧会影响左侧 #}
    //        if(xLeft <= paramTimeline.start && xLeft + wLeft >= xYear){
    //            let xLeftTo=Math.max(Math.min(xLeft,(xYear - wLeft)),paramTimeline.startLeft);
    //            $left.style.left=xLeftTo+"px";
    //            $left.style.display = ( xLeftTo >= paramTimeline.endRight )?"none":"flex";
    //        }
    //        if(xLeft >= paramTimeline.end - wLeft && xLeft + wLeft >= xYear){
    //            let xYearTo=Math.min(Math.max(xLeft + wLeft, xYear),paramTimeline.endRight);
    //            $year.style.left=xYearTo+"px";
    //            $year.style.display = ( xYearTo >= paramTimeline.endRight )?"none":"flex";
    //        }            
    //    }
    //}
    function updateTimelineBar(position={x:0}){
        let $listYears=$timelineYearContainer.querySelectorAll("#timelineYearContainer .timelineYear");
        $listYears.forEach(($year,idx,$list)=>{
            updateBnYear(position,$year,idx,$list);
        })
        //$listYears.forEach(pushBnYear);
    }
    this.bsTimelineBarWrapper.on('scroll', updateTimelineBar);
    updateTimelineBar();
</script>