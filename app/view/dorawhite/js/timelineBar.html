<script>
    this.bsTimelineBarWrapper = new BetterScroll.createBScroll('#bsTimelineBarWrapper', {
        //specifiedIndexAsContent:1,
        disableMouse: false,
        disableTouch: false,
        scrollX: true,
        scrollY: false,
        //nestedScroll: {
        //    groupId: 'cover-scrollY'
        //},
        //slide: {
        //    threshold: 100,
        //    loop: false,//TODO：可以优化为循环slide；注意：复制出来的slide需要querySelector and 设置translateY同步
        //    autoplay:false,
        //    listenFlick:false,
        //},
        useTransition: true,
        momentum: true,
        //momentumLimitTime:100,//{# 快速滑动的时间小于xx开启#}
        //momentumLimitDistance:50,//{# 快速滑动的距离大于xx开启#}
        //deceleration:0.005,//{# momentum 动画的减速度 #}
        //swipeTime:300,//{# momentum 动画时长 #}
        bounce: {
            top: true,
            bottom: true,
            left: true,
            right: true
        },
        mouseWheel: {
            speed: 50,
            invert: false,
            easeTime: 100
        },
        observeDOM: true ,// 开启 observe-dom 插件
        stopPropagation: true,
        probeType: 3,
    })
    {# 手机版使用坐标转换 #}
    this.bsTimelineBarWrapper.scroller.actions.hooks.on('coordinateTransformation', (transformateDeltaData) => { 
        // 获取用户手指移动的距离
        const originDeltaX = transformateDeltaData.deltaX
        const originDeltaY = transformateDeltaData.deltaY
        // 变换位移
        transformateDeltaData.deltaX = this.$footer.isRotated?originDeltaY:originDeltaX;// transformateDeltaData.deltaX 最终作用在 BetterScroll content DOM 的 translateX
        transformateDeltaData.deltaY = this.$footer.isRotated?originDeltaX:originDeltaY;// transformateDeltaData.deltaY 最终作用在 BetterScroll content DOM 的 translateY
    })
    {# 移动中对齐内容，控制年份跟踪 #}
    //this.bsTimelineBarWrapper.scroller.translater.hooks.on('translate', (point) => {
    //    let bs=this.bsTimelineBarWrapper;
    //    let $timelineYearContainer=document.getElementById("timelineYearContainer");
    //    let $firstYear=$timelineYearContainer.querySelector("#timelineYearContainer .timelineYear");
    //    $firstYear.style.left = point.x + "px";
    //})

    let $bsTimelineBarWrapper=document.getElementById("bsTimelineBarWrapper");
    let $timelineYearContainer=document.getElementById("timelineYearContainer");
    let $svgTimelineBar=document.getElementById("svgTimelineBar");
    {# 找到当前日期 #}
    this.bsTimelineBarWrapper.findDateNow=function(position){
        let $listDocs=$svgTimelineBar.querySelectorAll(".b-d");
        let $docNow=Array.from($listDocs).find(($doc,idx,$list)=>{
            return $doc.x.baseVal.value >= -position.x -1;//动画导致对齐存在误差，保留1像素
        })
        return $docNow;
    }
    {# 设置class标记，并恢复上一个 #}
    this.bsTimelineBarWrapper.getNewStrDate=function(){
        if(that.bsTimelineBarWrapper.$docNow){
            let strDate=that.bsTimelineBarWrapper.$docNow.id.replace("b","");
            that.bsTimelineBarWrapper.$docNow.classList.add("now");

            {# 是否需要改变class #}
            that.bsTimelineBarWrapper.$docLast=that.bsTimelineBarWrapper.$docLast || that.bsTimelineBarWrapper.$docNow;
            {# $docNow有变化 #}
            if(that.bsTimelineBarWrapper.$docNow != that.bsTimelineBarWrapper.$docLast){                
                that.bsTimelineBarWrapper.$docLast.classList.remove("now");
                that.bsTimelineBarWrapper.$docLast=that.bsTimelineBarWrapper.$docNow;                
                return strDate;
            }else return false;

        }else debugger
        return false;
    }
    this.bsTimelineBarWrapper.updateBnYear = function(paramTimeline,$year,idx,$list){

        let strYear=$year.querySelector("span").innerText;

        let $timelineBarYearGroup=$svgTimelineBar.getElementById("timelineBarYearGroup"+strYear);
        let $yearPos=document.getElementById("timelineBarYear"+strYear);
        {# 计算过程 #}
        {# 宽度 #}
        //let wTimelineYearGroup=$timelineBarYearGroup.attributes["width-year"].value * $svgTimelineBar.clientWidth/100;
        {# 年坐标在wrapper中的相对x% #}
        //let xOffset = $svgTimelineBar.clientWidth*($yearPos.attributes.x.value.replace("%","")/100)+paramTimeline.position.x;//Math.max(0,position.x + "px");
        let xOffset = $yearPos.x.baseVal.value + paramTimeline.position.x + paramTimeline.paddingLeft;
        let xTo=(paramTimeline.start+Math.round(xOffset));//$year.style.left-xOffset;
        

        {# z-index #}
        if(xTo<paramTimeline.end && xTo>paramTimeline.start)$year.style["z-index"]=4000;
        else if(xTo<paramTimeline.start)$year.style["z-index"]=4000-strYear;
        else if(xTo>paramTimeline.end)$year.style["z-index"]=strYear;

        {# 判断是否超出右停止位 #}
        xTo=Math.max(Math.min(xTo,paramTimeline.stopEnd),paramTimeline.stopStart);

        {# 碰撞挤出 检查左侧#}
        let $left= idx>0 ? $list[idx-1] : false;    
        if($left){
            let xLeft=$left.style.opacity!="0" ? parseInt($left.style.left.replace("px","")):false;
            {# 只有最左侧才往左推，否则右侧会影响左侧 #}
            if(xLeft <= paramTimeline.stopStart && xLeft + paramTimeline.wYear >= xTo){
                let xLeftTo=Math.max(Math.min(xLeft,(xTo - paramTimeline.wYear)),paramTimeline.stopStartLeft);
                $left.style.left=xLeftTo+"px";
                {# $left.style.opacity = ( xLeftTo <= paramTimeline.stopStartLeft )?"0":"1"; #}
                $left.style.opacity = Math.abs(( xLeftTo - paramTimeline.stopStartLeft )/paramTimeline.wYear);
            }
            {# 左推右，必须在end附近，否则循环修改 #}
            {# if(xTo >= paramTimeline.stopEnd)xTo=Math.min(Math.max(xLeft + paramTimeline.wYear, xTo),paramTimeline.stopEndRight); #}
            if(xTo >= paramTimeline.stopEnd)xTo=Math.min(Math.max(xLeft + paramTimeline.wYear, xTo),paramTimeline.stopEndLast);
        }
        {# 调整过左侧，最后确定自身坐标 #}
        $year.style.left=xTo+"px";
        {# $year.style.opacity = ( xTo >= paramTimeline.endRight )?"0":"1"; #}
        {# $year.style.opacity = Math.abs(( xTo - paramTimeline.endRight )/paramTimeline.wYear); #}
        $year.style.opacity = Math.abs(( xTo - paramTimeline.stopEndLast )/paramTimeline.wYear);
    }
    {# 检查并触发事件 #}
    that.bsTimelineBarWrapper.checkEvent=function(strEvent="BS_TIMELINE_BAR_DATE_CHANGE"){
        {# 日期变化，且用户操作产生的，才触发同步通知 #}
        let strNewDate=that.bsTimelineBarWrapper.getNewStrDate();
        if(strNewDate && that.bsTimelineBarWrapper.enabled){
            {# console.log("timelineBar:onScroll:时间轴日期有变化:触发",strEvent,strNewDate,pos.x); #}
            {# 触发事件 #}
            that.dispatchEvent(new CustomEvent(strEvent, {
                detail:{
                    strDateNow:strNewDate,
                }
            }))
        }
    }
    function updateTimelineBar(position={x:0}){
        {# 初始化参数 #}
        let paramTimeline={
            wWrapper:$bsTimelineBarWrapper.clientWidth,
            wYear:$timelineYearContainer.querySelector("#timelineYearContainer .timelineYear span").clientWidth,
            paddingLeft:$bsTimelineBarWrapper.querySelector(".bsTimelineBarContent .left").clientWidth,
        }
        {# 位置 #}
        Object.assign(paramTimeline,{
            startLeft: (-paramTimeline.wWrapper - paramTimeline.wYear),
            start: -paramTimeline.wWrapper,
            end:0,
            endRight:paramTimeline.wYear,
            endLast:paramTimeline.wYear*2,

            stopStart:that.$footer.isRotated?-paramTimeline.wWrapper : (-paramTimeline.wWrapper + 95),
            stopStartLeft:that.$footer.isRotated ? (-paramTimeline.wWrapper - paramTimeline.wYear) : (-paramTimeline.wWrapper - paramTimeline.wYear + 95),
            stopEnd:that.$footer.isRotated ? -paramTimeline.wYear *2 : -paramTimeline.wYear*3/2,
            stopEndRight:that.$footer.isRotated ? -paramTimeline.wYear : -paramTimeline.wYear/2,
            stopEndLast:that.$footer.isRotated ? 0 : paramTimeline.wYear/2,
            
            position:position,
        })
        let $listYears=$timelineYearContainer.querySelectorAll("#timelineYearContainer .timelineYear");
        $listYears.forEach(($year,idx,$list)=>{
            that.bsTimelineBarWrapper.updateBnYear(paramTimeline,$year,idx,$list);
        })
        {# 找到当前日期 #}
        that.bsTimelineBarWrapper.$docNow=that.bsTimelineBarWrapper.findDateNow(position);
        
        {# 如果已经到位 #}
        //if(Math.abs(that.bsTimelineBarWrapper.$docNow.x.baseVal.value + position.x ) <= 5 )that.bsTimelineBarWrapper.checkEvent("BS_TIMELINE_BAR_DATE_CHANGE_FINAL");
        //else that.bsTimelineBarWrapper.checkEvent("BS_TIMELINE_BAR_DATE_CHANGE");
        that.bsTimelineBarWrapper.checkEvent("BS_TIMELINE_BAR_DATE_CHANGE");
    }
    this.bsTimelineBarWrapper.on('scroll', updateTimelineBar);

    this.bsTimelineBarWrapper.scroller.animater.hooks.on('end', () => {
        this.bsTimelineBarWrapper.enable();
        console.log("底条animater.end停止");
    })
    this.bsTimelineBarWrapper.scroller.hooks.on("scrollEnd", () => {
        this.bsTimelineBarWrapper.enable();
        that.bsTimelineBarWrapper.$docNow=that.bsTimelineBarWrapper.findDateNow({x:that.bsTimelineBarWrapper.x,y:that.bsTimelineBarWrapper.y});
        if(that.bsTimelineBarWrapper.$docNow){
            let strNowDate=that.bsTimelineBarWrapper.$docNow.id.replace("b","");
            {# 触发事件 #}
            {# console.log("timelineBar:scrollEnd:触发FINAL",that.bsTimelineBarWrapper.$docNow.id,that.bsTimelineBarWrapper.$docNow.x.baseVal.value); #}
            that.dispatchEvent(new CustomEvent("BS_TIMELINE_BAR_DATE_CHANGE_FINAL", {
                detail:{
                    strDateNow:strNowDate,
                }
            }))
        }
        console.log("底条scrollEnd停止");
    })

    
    
    {# 时间轴scroll #}
    this.addEventListener("BS_MAIN_DATE_CHANGE",(e)=>{
        {# 如果日期没变化，不额外触发，方式循环控制 #}
        let strDateNow=that.bsTimelineBarWrapper.$docNow.id.replace("b","");
        if(e.detail.strDateNow == strDateNow)return;
        let $dateTo=document.getElementById("b"+e.detail.strDateNow);
        let posX=-$dateTo.x.baseVal.value;//-$dateTo.x*$svgTimelineBar.clientWidth;
        console.log("e::timelineBar::",e.type,strDateNow,"==>",e.detail.strDateNow,posX);

        that.bsTimelineBarWrapper.disable();
        that.bsTimelineBarWrapper.scrollTo(posX,0,300);
    })
    {# 到时间轴页时才更新bar坐标 #}
    this.addEventListener("BS_COVER_WILL_TIMELINE", (page)=>{
        updateTimelineBar();
    })
</script>